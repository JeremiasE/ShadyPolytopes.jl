import Singular
import SemialgebraicSets
import MultivariatePolynomials

"""
    create_singular_ring(dp_vars)

Creates a the ring QQ[`dp_vars`] as a Singular.jl ring.
Returns the ring and the Singular.jl variables.
"""

function create_singular_ring(dp_vars)
    var_names = [MultivariatePolynomials.name(t) for t in dp_vars]
    return Singular.polynomial_ring(Singular.QQ, var_names)
end

"""
    singular_ideal(eqs, sg_ring, dp_vars, sg_vars)

Returns a Singular.jl ideal generated by the MultivariatePolynomials.jl polynomials `polys`.
`sg_ring` is the Singular ring to use, `dp_vars` and
`sg_vars` are vectors of corresponding MultivariatePolynomials and Singular variables.
"""
function singular_ideal(polys, sg_ring, dp_vars, sg_vars)
    sg_eqs = [convert_dynpoly_to_singpoly(p, sg_ring, dp_vars, sg_vars) for p in polys]
    return Singular.Ideal(sg_ring, sg_eqs)
end

"""
    lift_polynomials(eqs, polys, dp_vars)

Calculates a matrix ``A`` in QQ[`dp_vars`] such that
A'*eqs = polys. The entries of A are polynomials in MultivariatePolynomials.
"""
function lift_polynomials(eqs, polys, dp_vars)
    sg_ring, sg_vars = create_singular_ring(dp_vars)
    eqs_ideal = singular_ideal(eqs, sg_ring, dp_vars, sg_vars)
    polys_ideal = singular_ideal(polys, sg_ring, dp_vars, sg_vars)
    A, B = Singular.lift(eqs_ideal, polys_ideal)
    return sg_matrix_to_dp_matrix(Singular.Matrix(A), dp_vars), sg_matrix_to_dp_matrix(Singular.Matrix(B), dp_vars)
end

"""
    sg_matrix_to_dp_matrix(M, dp_vars)

Convert the Singular.jl matrix M to
a matrix of the same size whose entries
are MultivariatePolynomials over the variables `dp_vars`.
"""
function sg_matrix_to_dp_matrix(M, dp_vars)
    n = Singular.nrows(M)
    m = Singular.ncols(M)
    A = zeros(typeof(dp_vars[1]+big(1)//2),n,m)
    for i in 1:n
        for j in 1:m
            A[i,j] = convert_singpoly_to_dynpoly(M[i,j],dp_vars)
        end
    end
    return A
end

"""
    convert_singpoly_to_dynpoly(singpoly, dp_vars)

Convert the Singular.jl polynomials `singpoly
to a MultivariatePolynomials polynomial over the variables `dp_vars`.
"""
function convert_singpoly_to_dynpoly(singpoly, dp_vars)
    result = 0
    coeffs = map(x->convert(Rational{BigInt},x),Singular.coefficients(singpoly))
    monoexpos = collect(Singular.exponent_vectors(singpoly))
    for (coef,expo) in zip(coeffs,monoexpos)
        result += coef*prod(t^k for (t,k) in zip(dp_vars,expo))
    end
    return result
end


"""
    convert_dynpoly_to_singpoly(dynpoly, sg_ring, dp_vars, sg_vars)

Convert the MultivariatePolynomials `dynpoly` over the variables `dp_vars`
into a Singular polynomial in `sg_ring[sg_vars]`.
"""
function convert_dynpoly_to_singpoly(dynpoly, sg_ring, dp_vars, sg_vars)
    d = Dict(zip(dp_vars, sg_vars))
    used_dp_vars = MultivariatePolynomials.variables(dynpoly)
    used_sg_vars = [d[v] for v in used_dp_vars]

    result = sg_ring(0)
    
    for term in MultivariatePolynomials.terms(dynpoly)
        coef = MultivariatePolynomials.coefficients(term)[1]
        expo = MultivariatePolynomials.exponents(term)
        result += coef*prod(t^k for (t,k) in zip(used_sg_vars,expo))
    end

    return result
end
